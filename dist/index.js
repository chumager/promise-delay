"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.wrapper=wrapper,exports.errors=exports.functions=exports.default=void 0;const PromiseDelay=Symbol("PromiseDelay");let functions={};function wrapper(r,{Static:e,Method:t,depends:a=[]}){const o=(o=Promise,s=!1)=>{a.forEach(r=>{functions[r](o)}),t&&(o.prototype[r]&&!s||(o.prototype[r]=t)),e&&(o[r]&&!s||(o[r]=e),o.prototype[r]||(o.prototype[r]=function(...e){return this.constructor[r](this,...e)}))};return functions[r]=o,o}exports.functions=functions,wrapper("delay",{Static(r=100,e){return new this((t,a)=>{setTimeout(t,r,e),this.resolve(e).catch(a)})},Method(r=100){const e=this.constructor;return this.then(t=>e.delay(r,t))}}),wrapper("atLeast",{Static(r,e=100){const t=Date.now();return this.resolve(r).then(r=>{const a=Date.now()-t;return e>a?new this(t=>setTimeout(t,e-a,r)):r})}}),wrapper("timeout",{Static(r,e,t){if("number"!=typeof e)throw createError("PromiseTimeoutError","time is not a number");return new this((a,o)=>{setTimeout(()=>{o(createError("PromiseTimeoutError",t||`Promise timeout in ${e}ms`,{time:e}))},e);const s="function"==typeof r?r:()=>r;this.resolve(s()).then(a,o)})}}),wrapper("timeoutDefault",{Static(r,e=100,t,a=!1){return r=this.resolve(r),void 0===t?this.reject(createError("PromiseTimeoutDefaultError","there is no default for timeoutDefault")):new this((o,s)=>{setTimeout(()=>{o(t)},e),r.then(o,r=>{if(a)return o(t);s(r)})})}}),wrapper("uncatch",{async Static(r,e=(r=>r)){return this.resolve(r).catch(e)}}),wrapper("map",{async Static(r,e,{catchError:t=!0,parallel:a=!1}={}){const o=[];let s=0;try{if(!(r=await r)[Symbol.iterator])throw createError("PromiseIterableError","trying to use map without an iterable object",{iterable:r});for(let i of r)try{i=await i,a?o.push(e(i,s,r)):o.push(await e(i,s,r))}catch(e){if(t)return this.reject(createError("PromiseMapError","some callback trows an error",{iterable:r,id:s,result:o,err:e}));o.push(e)}finally{s++}}catch(e){if(e instanceof errors.PromiseIterableError)throw e;return this.reject(createError("PromiseMapError","some callback or iterable ",{iterable:r,id:s,result:o,err:e}))}return a?this.all(o):o}}),wrapper("sequence",{async Static(r,{catchError:e=!0,delay:t=null,atLeast:a=null}){const o=r=>{if("number"==typeof r)return this.delay(r,PromiseDelay);let e=this.resolve(r());return t&&(e=e.delay(t)),a&&(e=e.atLeast(a)),e};try{return(await this.map(r,o,{catchError:e})).reduce((r,e)=>(e!==PromiseDelay&&r.push(e),r),[])}catch(r){if(r instanceof errors.PromiseMapError){const{iterable:e,id:t,result:a,err:o}=r;return this.reject(createError("PromiseSequenceError","some callback or iterable throws error"),{iterable:e,id:t,result:a,err:o})}return this.reject(r)}},depends:["map"]}),wrapper("sequenceAllSettled",{async Static(r,{delay:e=null,atLeast:t=null}){const a=async r=>{if("number"==typeof r)return this.delay(r,PromiseDelay);try{let a=this.resolve(r());return e&&(a=a.delay(e)),t&&(a=a.atLeast(t)),{status:"fulfilled",value:await a}}catch(r){return{status:"rejected",reason:r}}};try{return(await this.map(r,a)).reduce((r,e)=>(e!==PromiseDelay&&r.push(e),r),[])}catch(r){if(r instanceof errors.PromiseMapError){const{iterable:e,id:t,result:a,err:o}=r;return this.reject(createError("PromiseSequenceError","some callback or iterable throws error"),{iterable:e,id:t,result:a,err:o})}return this.reject(r)}}}),wrapper("waterfall",{async Static(r,{delay:e=null,atLeast:t=null,initVal:a}){let o,s=a,i=0;try{if(!(r=await r)[Symbol.iterator])throw createError("PromiseIterableError","trying to use sequence withour an iterable object",{iterable:r,delay:e,atLeast:t,initVal:a});for await(let a of r){if(o=s,!["function","number"].includes(typeof a))throw createError("PromiseIterableError","iterable is neither function nor number");"number"!=typeof a?(s=a(s),e&&(s=this.resolve(s).delay(e)),t&&(s=this.resolve(s).atLeast(t)),s=await s,i++):await new this(r=>setTimeout(r,a))}}catch(r){const e=createError("PromiseIterableError","some iterable throws error");return e.innerError=r,e.args={lastResult:o,id:i},this.reject(e)}return s}}),wrapper("reduce",{async Static(r,e,t,{delay:a=null,atLeast:o=null}){let s=t,i=0;try{if(!(r=await r)[Symbol.iterator])throw createError("PromiseIterableError","trying to use sequence withour an iterable object",{iterable:r,delay:a,atLeast:o,initVal:t});for await(const t of r)s=await e(s,t,i,r),i++}catch(r){const e=createError("PromiseIterableError","some iterable throws error");return e.innerError=r,e.args={result:s,id:i},this.reject(e)}return s}}),wrapper("get",{async Method(r){const e=this.constructor;try{const e=await(this);if(r in e)return e[r];throw createError("PromiseKeyNotFound",`key ${r} not found`,{result:e,key:r})}catch(r){return e.reject(r)}}}),wrapper("keys",{async Method(){return Object.keys(await(this))}}),wrapper("call",{async Method(r,...e){const t=await(this);if("function"!=typeof t)throw createError("PromiseCallableError","resulting promise is not a function",{thisObj:r,args:e});return t.call(r,...e)}}),wrapper("apply",{async Method(r,e){const t=await(this);if("function"!=typeof t)throw createError("PromiseCallableError","localPromise is not a function",{thisObj:r,args:e});return t.apply(r,e)}}),wrapper("exec",{async Method(...r){const e=await(this);if("function"!=typeof e)throw createError("PromiseCallableError","localPromise is not a function",{args:r});return e(...r)}}),wrapper("waitForKey",{async Static(r,e,{ellapsed:t=100,maxIterations:a=1e4}={}){try{if((e=await e)in r)return r[e];if(--a<0)throw createError("PromiseMaxIterationsError","Max iterations have been reached");return await new this(r=>setTimeout(r,t)),this.waitForKey(r,e,{ellapsed:t,maxIterations:a})}catch(r){return this.reject(r)}}}),wrapper("waitForResult",{async Static(r,{ellapsed:e=100,delay:t=null,atLeast:a=null,maxIterations:o=1e4,retry:s=!0,timeout:i=null}={},n=[]){Array.isArray(n)||(n=[n]);try{n=await this.all(n),r=await r;let l=this.resolve(r(...n));if(t&&(l=l.delay(t)),a&&(l=l.atLeast(a)),i&&(l=l.timeout(i)),l=await l,void 0!==l)return l;if(--o<0)throw createError("PromiseMaxIterationsError","Max iterations have been reached");return await new this(r=>setTimeout(r,e)),this.waitForResult(r,{ellapsed:e,delay:t,atLeast:a,maxIterations:o,retry:s},n)}catch(l){return l instanceof errors.PromiseMaxIterationsError?this.reject(l):s?this.waitForResult(r,{ellapsed:e,delay:t,atLeast:a,maxIterations:o,retry:s,timeout:i},n):this.reject(l)}}});const errors={};function createError(r,e,t){return errors[r]||(errors[r]=class extends Error{constructor(e,t){super(e),this.name=r,this.args=t}}),new errors[r](e,t)}function all(r=Promise){for(const e in functions)functions[e](r)}exports.errors=errors,Object.assign(all,functions,errors,{wrapper:wrapper});var _default=all;exports.default=_default;