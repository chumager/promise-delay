"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.errors=exports.functions=exports.default=void 0;let functions={};function wrapper(t,{Static:r,Method:e}){functions[t]=(a=Promise,o=!1)=>{e&&(a.prototype[t]&&!o||(a.prototype[t]=e)),r&&(a[t]&&!o||(a[t]=r),a.prototype[t]||(a.prototype[t]=function(...r){return this.constructor[t](this,...r)}))}}exports.functions=functions,wrapper("delay",{Static(t=100,r){return new this(e=>setTimeout(e,t,r))},Method(t=100){const r=this.constructor;return this.then(e=>new r(r=>setTimeout(r,t,e)))}}),wrapper("atLeast",{Method(t=100){const r=Date.now(),e=this.constructor;return this.then(a=>{const o=Date.now()-r;return t>o?new e(r=>setTimeout(r,t-o,a)):a})}}),wrapper("timeout",{Method(t,r){const e=this.constructor;let a,o;"string"==typeof t&&(r=t,t=100);const i=new e((t,r)=>{a=t,o=r});return setTimeout(()=>{let e=createError("PromiseTimeoutError",r||`Promise timeout in ${t}ms`,t);o(e)},t),this.then(a,o),i}}),wrapper("timeoutDefault",{Method(t=100,r={default:null,chainable:!0}){const e=this.constructor;if(null===r.default)return e.reject(createError("PromiseTimeoutDefaultError","there is no default for timeoutDefault"));let a,o;const i=new e((t,r)=>{a=t,o=r});return setTimeout(()=>{a(r.default)},t),this.then(a,t=>{if(r.chainable)return o(t);a(r.default)}),i}}),wrapper("sequence",{async Static(t,{delay:r=null,atLeast:e=null}){const a=[];try{if(!(t=await t)[Symbol.iterator])throw createError("PromiseIterableError","trying to use sequence without an iterable object",{iterable:t,delay:r,atLeast:e});for(let o of t){if(!["function","number"].includes(typeof o))throw createError("PromiseIterableError","iterable is neither function nor number");switch(typeof o){case"function":o=o();break;case"number":await new this(t=>setTimeout(t,o));continue}r&&(o=this.resolve(o).delay(r)),e&&(o=this.resolve(o).atLeast(e)),a.push(await o)}}catch(t){return t instanceof Error&&(t.args={result:a}),this.reject(t)}return a}}),wrapper("map",{async Static(t,r,{catchError:e=!0}={}){const a=[];let o=0;try{if(!(t=await t)[Symbol.iterator])throw createError("PromiseIterableError","trying to use map without an iterable object",{iterable:t});for(let i of t)try{i=await i,a.push(await r(i,o,t))}catch(r){if(e)return r instanceof Error&&(r.args={iterable:t,id:o,result:a}),this.reject(r);a.push(r)}finally{o++}}catch(t){return this.reject(t)}return a}}),wrapper("sequenceAllSettled",{async Static(t,{delay:r=null,atLeast:e=null}){const a=[];try{if(!(t=await t)[Symbol.iterator])throw createError("PromiseIterableError","trying to use sequence withour an iterable object",{iterable:t,delay:r,atLeast:e});for(let o of t){if(!["function","number"].includes(typeof o))throw createError("PromiseIterableError","iterable is neither function nor number");switch(typeof o){case"function":o=o();break;case"number":await new this(t=>setTimeout(t,o));continue}r&&(o=this.resolve(o).delay(r)),e&&(o=this.resolve(o).atLeast(e));try{const t=await o;a.push({status:"fulfilled",value:t})}catch(t){a.push({status:"rejected",reason:t})}}}catch(t){return t instanceof Error&&(t.args={result:a}),this.reject(t)}return a}}),wrapper("waterfall",{async Static(t,{delay:r=null,atLeast:e=null,initVal:a}){let o,i=a,s=0;try{if(!(t=await t)[Symbol.iterator])throw createError("PromiseIterableError","trying to use sequence withour an iterable object",{iterable:t,delay:r,atLeast:e,initVal:a});for(let a of t){if(o=i,!["function","number"].includes(typeof a))throw createError("PromiseIterableError","iterable is neither function nor number");"number"!=typeof a?(i=a(i),r&&(i=this.resolve(i).delay(r)),e&&(i=this.resolve(i).atLeast(e)),i=await i,s++):await new this(t=>setTimeout(t,a))}}catch(t){const r=createError("PromiseIterableError","some iterable throws error");return r.innerError=t,r.args={lastResult:o,id:s},this.reject(r)}return i}}),wrapper("reduce",{async Static(t,r,e,{delay:a=null,atLeast:o=null}){let i=e,s=0;try{if(!(t=await t)[Symbol.iterator])throw createError("PromiseIterableError","trying to use sequence withour an iterable object",{iterable:t,delay:a,atLeast:o,initVal:e});for await(const e of t)i=await r(i,e,s,t),s++}catch(t){const r=createError("PromiseIterableError","some iterable throws error");return r.innerError=t,r.args={result:i,id:s},this.reject(r)}return i}}),wrapper("get",{async Method(t){const r=this.constructor;try{const r=await(this);if(t in r)return r[t];throw createError("PromiseKeyNotFound",`key ${t} not found`,{result:r,key:t})}catch(t){return r.reject(t)}}}),wrapper("keys",{async Method(){return Object.keys(await(this))}}),wrapper("call",{async Method(t,...r){const e=await(this);if("function"!=typeof e)throw createError("PromiseCallableError","resulting promise is not a function",{thisObj:t,args:r});return e.call(t,...r)}}),wrapper("apply",{async Method(t,r){const e=await(this);if("function"!=typeof e)throw createError("PromiseCallableError","localPromise is not a function",{thisObj:t,args:r});return e.apply(t,r)}}),wrapper("exec",{async Method(...t){const r=await(this);if("function"!=typeof r)throw createError("PromiseCallableError","localPromise is not a function",{args:t});return r(...t)}}),wrapper("waitForKey",{async Static(t,r,{ellapsed:e=100,maxIterations:a=1e4}={}){try{if((r=await r)in t)return t[r];if(--a<0)throw createError("PromiseMaxIterationsError","Max iterations have been reached");return await new this(t=>setTimeout(t,e)),this.waitForKey(t,r,{ellapsed:e,maxIterations:a})}catch(t){return this.reject(t)}}}),wrapper("waitForResult",{async Static(t,{ellapsed:r=100,delay:e=null,atLeast:a=null,maxIterations:o=1e4,retry:i=!0,timeout:s=null}={},n=[]){Array.isArray(n)||(n=[n]);try{n=await this.all(n),t=await t;let c=this.resolve(t(...n));if(e&&(c=c.delay(e)),a&&(c=c.atLeast(a)),s&&(c=c.timeout(s)),c=await c,void 0!==c)return c;if(--o<0)throw createError("PromiseMaxIterationsError","Max iterations have been reached");return await new this(t=>setTimeout(t,r)),this.waitForResult(t,{ellapsed:r,delay:e,atLeast:a,maxIterations:o,retry:i},n)}catch(c){return c instanceof errors.PromiseMaxIterationsError?this.reject(c):i?this.waitForResult(t,{ellapsed:r,delay:e,atLeast:a,maxIterations:o,retry:i,timeout:s},n):this.reject(c)}}});const errors={};function createError(t,r,e){return errors[t]||(errors[t]=class extends Error{constructor(r,e){super(r),this.name=t,this.args=e}}),new errors[t](r,e)}function all(t=Promise){for(const r in functions)functions[r](t)}exports.errors=errors,Object.assign(all,functions,errors);var _default=all;exports.default=_default;