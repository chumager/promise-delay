"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.errors=exports.functions=exports.default=void 0;const functions={delay(e=Promise,t=!1){e.delay&&!t||(e.delay=(t=100,r)=>new e(e=>setTimeout(e,t,r)),e.prototype.delay=async function(t=100){try{const e=await(this);return await new Promise(r=>setTimeout(r,t,e))}catch(t){return e.reject(t)}})},atLeast(e=Promise,t=!1){e.prototype.delay&&!t||(e.prototype.atLeast=async function(e=100){const t=Date.now(),r=await(this),o=Date.now()-t;return e>o?await new Promise(t=>setTimeout(t,e-o,r)):r})},timeout(e=Promise){e.prototype.timeout=function(e=100,t){let r,o;"string"==typeof e&&(t=e,e=100);const a=new Promise((e,t)=>{r=e,o=t});return setTimeout(()=>{let r=createError("PromiseTimeoutError",t||`Promise timeout in ${e}ms`,e);o(r)},e),this.then(r,o),a}},timeoutDefault(e=Promise){e.prototype.timeoutDefault=function(e=100,t={default:null,chainable:!0}){if(null===t.default)return Promise.reject(createError("PromiseTimeoutDefaultError","there is no default for timeoutDefault"));let r,o;const a=new Promise((e,t)=>{r=e,o=t});return setTimeout(()=>{r(t.default)},e),this.then(r,e=>{if(t.chainable)return o(e);r(t.default)}),a}},sequence(e=Promise,t={delay:null,atLeast:null}){e.sequence=async(r,{delay:o=null,atLeast:a=null}=t)=>{if(!r[Symbol.iterator])throw createError("PromiseIterableError","trying to use sequence withour an iterable object",{iterable:r,delay:o,atLeast:a});const n=[];try{for(let t of r){if(!["function","number"].includes(typeof t))throw createError("PromiseIterableError","iterable is neither function nor number");switch(typeof t){case"function":t=t();break;case"number":await new e(e=>setTimeout(e,t));continue}o&&(t=e.resolve(t).delay(o)),a&&(t=e.resolve(t).atLeast(a)),n.push(await t)}}catch(t){return t instanceof Error&&(t.args={result:n}),e.reject(t)}return n}},waterfall(e=Promise,t={delay:null,atLeast:null}){e.waterfall=async(r,{delay:o=null,atLeast:a=null,initial:n}=t)=>{if(!r[Symbol.iterator])throw createError("PromiseIterableError","trying to use sequence withour an iterable object",{iterable:r,delay:o,atLeast:a,initial:n});let i=n,s=0;const l=[...r];try{for(s=0;s<l.length;s++){let t=l[s];if(!["function","number"].includes(typeof t))throw createError("PromiseIterableError","iterable is neither function nor number");"number"!=typeof t?(i=t(i),o&&(i=e.resolve(i).delay(o)),a&&(i=e.resolve(i).atLeast(a)),i=await i):await new e(e=>setTimeout(e,t))}}catch(t){const r=createError("PromiseIterableError","some iterable throws error");return r.innerError=t,r.args={result:i,id:s},e.reject(r)}return i}},get(e=Promise){e.prototype.get=async function(t){try{const e=await(this);if(t in e)return e[t];throw createError("PromiseKeyNotFound",`key ${t} not found`,{result:e,key:t})}catch(t){return e.reject(t)}}},keys(e=Promise){e.prototype.keys=async function(){return Object.keys(await(this))}},call(e=Promise){e.prototype.call=async function(e,...t){const r=await(this);if("function"!=typeof r)throw createError("PromiseCallableError","localPromise is not a function",{thisObj:e,args:t});return await r.call(e,...t)}},apply(e=Promise){e.prototype.apply=async function(e,t){const r=await(this);if("function"!=typeof r)throw createError("PromiseCallableError","localPromise is not a function",{thisObj:e,args:t});return await r.apply(e,t)}},exec(e=Promise){e.prototype.exec=async function(...e){const t=await(this);if("function"!=typeof t)throw createError("PromiseCallableError","localPromise is not a function",{args:e});return await t(...e)}},waitForKey(e=Promise,t={ellapsed:100,maxIterations:1e4}){e.waitForKey=async function(r,o,{ellapsed:a=100,maxIterations:n=1e4}=t){if(o in r)return r[o];if(--n<0)throw createError("PromiseMaxIterationsError","Max iterations have been reached");return await new e(e=>setTimeout(e,a)),e.waitForKey(r,o,{ellapsed:a,maxIterations:n})}},waitForResult(e=Promise,t={ellapsed:100,delay:null,atLeast:null,maxIterations:1e4,retry:!0,timeout:null}){e.waitForResult=async function(r,o,{ellapsed:a=100,delay:n=null,atLeast:i=null,maxIterations:s=1e4,retry:l=!0,timeout:u=null}=t){Array.isArray(o)||(o=[o]);try{let t=e.resolve(r(...o));if(n&&(t=t.delay(n)),i&&(t=t.atLeast(i)),u&&(t=t.timeout(u)),t=await t,void 0!==t)return t;if(--s<0)throw createError("PromiseMaxIterationsError","Max iterations have been reached");return e.waitForResult(r,o,{ellapsed:a,delay:n,atLeast:i,maxIterations:s,retry:l})}catch(t){return t instanceof errors.PromiseMaxIterationsError?e.reject(t):l?e.waitForResult(r,o,{ellapsed:a,delay:n,atLeast:i,maxIterations:s,retry:l,timeout:u}):e.reject(t)}}}};exports.functions=functions;const errors={};function createError(e,t,r){return errors[e]||(errors[e]=class extends Error{constructor(t,r){super(t),this.name=e,this.args=r}}),new errors[e](t,r)}function all(e=Promise){for(const t in functions)functions[t](e)}exports.errors=errors,Object.assign(all,functions,errors);var _default=all;exports.default=_default;