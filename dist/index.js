"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.wrapper=wrapper,exports.errors=exports.functions=exports.default=void 0;let functions={};function wrapper(r,{Static:t,Method:e,depends:a=[]}){const o=(o=Promise,i=!1)=>{a.forEach(r=>{functions[r](o)}),e&&(o.prototype[r]&&!i||(o.prototype[r]=e)),t&&(o[r]&&!i||(o[r]=t),o.prototype[r]||(o.prototype[r]=function(...t){return this.constructor[r](this,...t)}))};return functions[r]=o,o}exports.functions=functions,wrapper("delay",{Static(r=100,t){return new this((e,a)=>{setTimeout(e,r,t),this.resolve(t).catch(a)})},Method(r=100){const t=this.constructor;return this.then(e=>t.delay(r,e))}}),wrapper("atLeast",{Static(r,t=100){const e=Date.now();return this.resolve(r).then(r=>{const a=Date.now()-e;return t>a?new this(e=>setTimeout(e,t-a,r)):r})}}),wrapper("timeout",{Static(r,t,e){if("number"!=typeof t)throw createError("PromiseTimeoutError","time is not a number");return new this((a,o)=>{setTimeout(()=>{o(createError("PromiseTimeoutError",e||`Promise timeout in ${t}ms`,{time:t}))},t);const i="function"==typeof r?r:()=>r;this.resolve(i()).then(a,o)})}}),wrapper("timeoutDefault",{Static(r,t=100,e,a=!1){return r=this.resolve(r),void 0===e?this.reject(createError("PromiseTimeoutDefaultError","there is no default for timeoutDefault")):new this((o,i)=>{setTimeout(()=>{o(e)},t),r.then(o,r=>{if(a)return o(e);i(r)})})}}),wrapper("uncatch",{async Static(r,t=(r=>r)){return this.resolve(r).catch(t)}}),wrapper("map",{async Static(r,t,{catchError:e=!0}={}){const a=[];let o=0;try{if(!(r=await r)[Symbol.iterator])throw createError("PromiseIterableError","trying to use map without an iterable object",{iterable:r});for(let i of r)try{i=await i,a.push(await t(i,o,r))}catch(t){if(e)return t instanceof Error&&(t.args={iterable:r,id:o,result:a}),this.reject(t);a.push(t)}finally{o++}}catch(r){return this.reject(r)}return a}}),wrapper("sequence",{async Static(r,{delay:t=null,atLeast:e=null}){const a=[];try{if(!(r=await r)[Symbol.iterator])throw createError("PromiseIterableError","trying to use sequence without an iterable object",{iterable:r,delay:t,atLeast:e});for await(let o of r){if(!["function","number"].includes(typeof o))throw createError("PromiseIterableError","iterable is neither function nor number");switch(typeof o){case"function":o=o();break;case"number":await new this(r=>setTimeout(r,o));continue}t&&(o=this.resolve(o).delay(t)),e&&(o=this.resolve(o).atLeast(e)),a.push(await o)}}catch(r){return r instanceof Error&&(r.args={result:a}),this.reject(r)}return a}}),wrapper("sequenceAllSettled",{async Static(r,{delay:t=null,atLeast:e=null}){const a=[];try{if(!(r=await r)[Symbol.iterator])throw createError("PromiseIterableError","trying to use sequence withour an iterable object",{iterable:r,delay:t,atLeast:e});for(let o of r){if(!["function","number"].includes(typeof o))throw createError("PromiseIterableError","iterable is neither function nor number");switch(typeof o){case"function":o=o();break;case"number":await new this(r=>setTimeout(r,o));continue}t&&(o=this.resolve(o).delay(t)),e&&(o=this.resolve(o).atLeast(e));try{const r=await o;a.push({status:"fulfilled",value:r})}catch(r){a.push({status:"rejected",reason:r})}}}catch(r){return r instanceof Error&&(r.args={result:a}),this.reject(r)}return a}}),wrapper("waterfall",{async Static(r,{delay:t=null,atLeast:e=null,initVal:a}){let o,i=a,s=0;try{if(!(r=await r)[Symbol.iterator])throw createError("PromiseIterableError","trying to use sequence withour an iterable object",{iterable:r,delay:t,atLeast:e,initVal:a});for await(let a of r){if(o=i,!["function","number"].includes(typeof a))throw createError("PromiseIterableError","iterable is neither function nor number");"number"!=typeof a?(i=a(i),t&&(i=this.resolve(i).delay(t)),e&&(i=this.resolve(i).atLeast(e)),i=await i,s++):await new this(r=>setTimeout(r,a))}}catch(r){const t=createError("PromiseIterableError","some iterable throws error");return t.innerError=r,t.args={lastResult:o,id:s},this.reject(t)}return i}}),wrapper("reduce",{async Static(r,t,e,{delay:a=null,atLeast:o=null}){let i=e,s=0;try{if(!(r=await r)[Symbol.iterator])throw createError("PromiseIterableError","trying to use sequence withour an iterable object",{iterable:r,delay:a,atLeast:o,initVal:e});for await(const e of r)i=await t(i,e,s,r),s++}catch(r){const t=createError("PromiseIterableError","some iterable throws error");return t.innerError=r,t.args={result:i,id:s},this.reject(t)}return i}}),wrapper("get",{async Method(r){const t=this.constructor;try{const t=await(this);if(r in t)return t[r];throw createError("PromiseKeyNotFound",`key ${r} not found`,{result:t,key:r})}catch(r){return t.reject(r)}}}),wrapper("keys",{async Method(){return Object.keys(await(this))}}),wrapper("call",{async Method(r,...t){const e=await(this);if("function"!=typeof e)throw createError("PromiseCallableError","resulting promise is not a function",{thisObj:r,args:t});return e.call(r,...t)}}),wrapper("apply",{async Method(r,t){const e=await(this);if("function"!=typeof e)throw createError("PromiseCallableError","localPromise is not a function",{thisObj:r,args:t});return e.apply(r,t)}}),wrapper("exec",{async Method(...r){const t=await(this);if("function"!=typeof t)throw createError("PromiseCallableError","localPromise is not a function",{args:r});return t(...r)}}),wrapper("waitForKey",{async Static(r,t,{ellapsed:e=100,maxIterations:a=1e4}={}){try{if((t=await t)in r)return r[t];if(--a<0)throw createError("PromiseMaxIterationsError","Max iterations have been reached");return await new this(r=>setTimeout(r,e)),this.waitForKey(r,t,{ellapsed:e,maxIterations:a})}catch(r){return this.reject(r)}}}),wrapper("waitForResult",{async Static(r,{ellapsed:t=100,delay:e=null,atLeast:a=null,maxIterations:o=1e4,retry:i=!0,timeout:s=null}={},n=[]){Array.isArray(n)||(n=[n]);try{n=await this.all(n),r=await r;let c=this.resolve(r(...n));if(e&&(c=c.delay(e)),a&&(c=c.atLeast(a)),s&&(c=c.timeout(s)),c=await c,void 0!==c)return c;if(--o<0)throw createError("PromiseMaxIterationsError","Max iterations have been reached");return await new this(r=>setTimeout(r,t)),this.waitForResult(r,{ellapsed:t,delay:e,atLeast:a,maxIterations:o,retry:i},n)}catch(c){return c instanceof errors.PromiseMaxIterationsError?this.reject(c):i?this.waitForResult(r,{ellapsed:t,delay:e,atLeast:a,maxIterations:o,retry:i,timeout:s},n):this.reject(c)}}});const errors={};function createError(r,t,e){return errors[r]||(errors[r]=class extends Error{constructor(t,e){super(t),this.name=r,this.args=e}}),new errors[r](t,e)}function all(r=Promise){for(const t in functions)functions[t](r)}exports.errors=errors,Object.assign(all,functions,errors,{wrapper:wrapper});var _default=all;exports.default=_default;