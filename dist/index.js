"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.wrapper=wrapper,exports.errors=exports.functions=exports.default=void 0;let functions={};function wrapper(r,{Static:e,Method:t,depends:a=[]}){const o=(o=Promise,i=!1)=>{a.forEach(r=>{functions[r](o)}),t&&(o.prototype[r]&&!i||(o.prototype[r]=t)),e&&(o[r]&&!i||(o[r]=e),o.prototype[r]||(o.prototype[r]=function(...e){return this.constructor[r](this,...e)}))};return functions[r]=o,o}exports.functions=functions,wrapper("delay",{Static(r=100,e){return new this((t,a)=>{setTimeout(t,r,e),this.resolve(e).catch(a)})},Method(r=100){const e=this.constructor;return this.then(t=>e.delay(r,t))}}),wrapper("atLeast",{Static(r,e=100){const t=Date.now();return this.resolve(r).then(r=>{const a=Date.now()-t;return e>a?new this(t=>setTimeout(t,e-a,r)):r})}}),wrapper("timeout",{Static(r,e,t){if("number"!=typeof e)throw createError("PromiseTimeoutError","time is not a number");return new this((a,o)=>{setTimeout(()=>{o(createError("PromiseTimeoutError",t||`Promise timeout in ${e}ms`,{time:e}))},e);const i="function"==typeof r?r:()=>r;this.resolve(i()).then(a,o)})}}),wrapper("timeoutDefault",{Static(r,e=100,t,a=!1){return r=this.resolve(r),void 0===t?this.reject(createError("PromiseTimeoutDefaultError","there is no default for timeoutDefault")):new this((o,i)=>{setTimeout(()=>{o(t)},e),r.then(o,r=>{if(a)return o(t);i(r)})})}}),wrapper("uncatch",{async Static(r,e=(r=>r)){return this.resolve(r).catch(e)}}),wrapper("map",{async Static(r,e,{catchError:t=!0,parallel:a=!0}={}){const o=[];let i=0;try{if(!(r=await r)[Symbol.iterator])throw createError("PromiseIterableError","trying to use map without an iterable object",{iterable:r});for(let s of r)try{s=await s,a?o.push(e(s,i,r)):o.push(await e(s,i,r))}catch(e){if(t)return this.reject(createError("PromiseMapError","some callback trows an error",{iterable:r,id:i,result:o,err:e}));o.push(e)}finally{i++}}catch(e){if(e instanceof errors.PromiseIterableError)throw e;return this.reject(createError("PromiseMapError","some callback or iterable rejects",{iterable:r,id:i,result:o,err:e}))}return a?this.all(o):o}}),wrapper("sequence",{async Static(r,{delay:e=null,atLeast:t=null}){const a=[];try{if(!(r=await r)[Symbol.iterator])throw createError("PromiseIterableError","trying to use sequence without an iterable object",{iterable:r,delay:e,atLeast:t});for await(let o of r){if(!["function","number"].includes(typeof o))throw createError("PromiseIterableError","iterable is neither function nor number");switch(typeof o){case"function":o=o();break;case"number":await new this(r=>setTimeout(r,o));continue}e&&(o=this.resolve(o).delay(e)),t&&(o=this.resolve(o).atLeast(t)),a.push(await o)}}catch(r){return r instanceof Error&&(r.args={result:a}),this.reject(r)}return a}}),wrapper("sequenceAllSettled",{async Static(r,{delay:e=null,atLeast:t=null}){const a=[];try{if(!(r=await r)[Symbol.iterator])throw createError("PromiseIterableError","trying to use sequence withour an iterable object",{iterable:r,delay:e,atLeast:t});for(let o of r){if(!["function","number"].includes(typeof o))throw createError("PromiseIterableError","iterable is neither function nor number");switch(typeof o){case"function":o=o();break;case"number":await new this(r=>setTimeout(r,o));continue}e&&(o=this.resolve(o).delay(e)),t&&(o=this.resolve(o).atLeast(t));try{const r=await o;a.push({status:"fulfilled",value:r})}catch(r){a.push({status:"rejected",reason:r})}}}catch(r){return r instanceof Error&&(r.args={result:a}),this.reject(r)}return a}}),wrapper("waterfall",{async Static(r,{delay:e=null,atLeast:t=null,initVal:a}){let o,i=a,s=0;try{if(!(r=await r)[Symbol.iterator])throw createError("PromiseIterableError","trying to use sequence withour an iterable object",{iterable:r,delay:e,atLeast:t,initVal:a});for await(let a of r){if(o=i,!["function","number"].includes(typeof a))throw createError("PromiseIterableError","iterable is neither function nor number");"number"!=typeof a?(i=a(i),e&&(i=this.resolve(i).delay(e)),t&&(i=this.resolve(i).atLeast(t)),i=await i,s++):await new this(r=>setTimeout(r,a))}}catch(r){const e=createError("PromiseIterableError","some iterable throws error");return e.innerError=r,e.args={lastResult:o,id:s},this.reject(e)}return i}}),wrapper("reduce",{async Static(r,e,t,{delay:a=null,atLeast:o=null}){let i=t,s=0;try{if(!(r=await r)[Symbol.iterator])throw createError("PromiseIterableError","trying to use sequence withour an iterable object",{iterable:r,delay:a,atLeast:o,initVal:t});for await(const t of r)i=await e(i,t,s,r),s++}catch(r){const e=createError("PromiseIterableError","some iterable throws error");return e.innerError=r,e.args={result:i,id:s},this.reject(e)}return i}}),wrapper("get",{async Method(r){const e=this.constructor;try{const e=await(this);if(r in e)return e[r];throw createError("PromiseKeyNotFound",`key ${r} not found`,{result:e,key:r})}catch(r){return e.reject(r)}}}),wrapper("keys",{async Method(){return Object.keys(await(this))}}),wrapper("call",{async Method(r,...e){const t=await(this);if("function"!=typeof t)throw createError("PromiseCallableError","resulting promise is not a function",{thisObj:r,args:e});return t.call(r,...e)}}),wrapper("apply",{async Method(r,e){const t=await(this);if("function"!=typeof t)throw createError("PromiseCallableError","localPromise is not a function",{thisObj:r,args:e});return t.apply(r,e)}}),wrapper("exec",{async Method(...r){const e=await(this);if("function"!=typeof e)throw createError("PromiseCallableError","localPromise is not a function",{args:r});return e(...r)}}),wrapper("waitForKey",{async Static(r,e,{ellapsed:t=100,maxIterations:a=1e4}={}){try{if((e=await e)in r)return r[e];if(--a<0)throw createError("PromiseMaxIterationsError","Max iterations have been reached");return await new this(r=>setTimeout(r,t)),this.waitForKey(r,e,{ellapsed:t,maxIterations:a})}catch(r){return this.reject(r)}}}),wrapper("waitForResult",{async Static(r,{ellapsed:e=100,delay:t=null,atLeast:a=null,maxIterations:o=1e4,retry:i=!0,timeout:s=null}={},n=[]){Array.isArray(n)||(n=[n]);try{n=await this.all(n),r=await r;let c=this.resolve(r(...n));if(t&&(c=c.delay(t)),a&&(c=c.atLeast(a)),s&&(c=c.timeout(s)),c=await c,void 0!==c)return c;if(--o<0)throw createError("PromiseMaxIterationsError","Max iterations have been reached");return await new this(r=>setTimeout(r,e)),this.waitForResult(r,{ellapsed:e,delay:t,atLeast:a,maxIterations:o,retry:i},n)}catch(c){return c instanceof errors.PromiseMaxIterationsError?this.reject(c):i?this.waitForResult(r,{ellapsed:e,delay:t,atLeast:a,maxIterations:o,retry:i,timeout:s},n):this.reject(c)}}});const errors={};function createError(r,e,t){return errors[r]||(errors[r]=class extends Error{constructor(e,t){super(e),this.name=r,this.args=t}}),new errors[r](e,t)}function all(r=Promise){for(const e in functions)functions[e](r)}exports.errors=errors,Object.assign(all,functions,errors,{wrapper:wrapper});var _default=all;exports.default=_default;